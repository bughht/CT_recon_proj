# Methods and Materials

## Dataset: 

ScanData and RefData for GREEN and RED: 320 BMP images of uint16 data type, loaded with numpy.

```python
def load_data(self,path,offset=27):
    data = np.zeros((self.img_w, self.img_num, self.img_h))
    for slice_idx, data_name in enumerate(os.listdir(path)):
        with open(os.path.join(path,data_name), 'rb') as f:
            data[:,slice_idx,:] = np.fromfile(f, dtype=np.uint16)[offset:].reshape(self.img_w,self.img_h)
    return data
```

Calibration parameters: xml version 1 data, loaded with beautifulsoup.

```python
class Calibration_data:
    def __init__(self, path) -> None:
        with open(path,encoding='utf-8') as f_calib:
            self.data_calib=BeautifulSoup(f_calib.read(), "xml")
        self.SourceToAxis=float(self.data_calib.find('SourceToAxis').text)
        self.AxisToDetector=float(self.data_calib.find('AxisToDetector').text)
        self.HorizLightSize=float(self.data_calib.find('HorizLightSize').text)
        self.VertLightSize=float(self.data_calib.find('VertLightSize').text)
        self.AxisOfRotationOffset=float(self.data_calib.find('AxisOfRotationOffset').text)
        self.EquatoralOffset=float(self.data_calib.find('EquatorialOffset').text)
        self.HorizPixelSize=float(self.data_calib.find('HorizPixelSize').text)
        self.VertPixelSize=float(self.data_calib.find('VertPixelSize').text)
```

## Preprocessing:

Preprocessing is performed on the data to produce a high quality sinogram for the FBP reconstruction. The following steps are taken:

1. Flat field correction: 

```python
self.data = np.log10(self.ref_data/self.scan_data)
```

2. Filtering to reduce ring artifacts:

```python
kernel_size = [5,1,5]
self.data = gaussian_filter(self.data, sigma=kernel_size)
```

3. Geometry correction: Shift the data by the offset of the axis of rotation.

```python
self.Calibration = Calibration_data(os.path.join(path,'calibration.xml'))
self.data = np.roll(self.data, -int(self.Calibration.AxisOfRotationOffset), axis=2)
```

4. Calculate the parameters for FBP reconstruction:

```python
def calculate_param(self):
    self.detector_pixel_size = self.Calibration.HorizPixelSize / self.img_h
    self.source_origin = self.Calibration.SourceToAxis/self.detector_pixel_size
    self.origin_det = self.Calibration.AxisToDetector/self.detector_pixel_size
```

## Reconstruction:

Using the ASTRA toolbox Python API, the FBP reconstruction is performed with the following process:

1. Create the geometry of the system and assign the parameters:

```python
cone_geom = astra.create_proj_geom(
    'cone',
    1,
    1,
    data.data.shape[0],
    data.data.shape[2],
    np.linspace(0, 2*np.pi, 320, endpoint=False),
    data.source_origin,
    data.origin_det
)
sinogram_id = astra.data3d.create(datatype='-sino', data=data.data, geometry=cone_geom)
vol_geom = astra.create_vol_geom(640,640,480)
```

2. Initialize the FBP algorithm and perform the reconstruction, then get the reconstructed volume of 640x640x640:

```python
vol_geom = astra.create_vol_geom(640,640,480)
cfg = astra.astra_dict('FDK_CUDA')
cfg['ReconstructionDataId'] = astra.data3d.create(datatype='-vol', geometry=vol_geom,data=0)
cfg['ProjectionDataId'] = sinogram_id
alg_id = astra.algorithm.create(cfg)

astra.algorithm.run(alg_id, 1)
recon = astra.data3d.get(cfg['ReconstructionDataId'])
sinogram = astra.data3d.get(cfg['ProjectionDataId'])
```

## Analysis

1. ROI segmentation: 3 colors x 4 layers. ROI is generated by manually selecting the cylindrical region of interest in the reconstructed volume.

```python
layer = np.array([
    [70, 120],
    [155, 205],
    [240, 290],
    [325, 375]
])

r = 55

center_red = np.array([
    [210, 350],
    [320, 200],
    [405, 400]
])
center_green = np.array([
    [225, 370],
    [300, 210],
    [420, 370]
])

def msk_generate(recon, center, layer, r):
    rr, cc = disk((center[0], center[1]), r, shape = recon.shape[1:])
    msk = np.zeros_like(recon, dtype=bool)
    msk[layer[0]:layer[1], rr, cc] = 1
    return msk

ROI_red = []
ROI_green = []

for center_idx in range(3):
    for l in layer:
        ROI_red.append(msk_generate(recon_red, center_red[center_idx], l, r))
        ROI_green.append(msk_generate(recon_green, center_green[center_idx], l, r))

ROI_red = np.array(ROI_red).reshape(3,4, *recon_red.shape)
ROI_green = np.array(ROI_green).reshape(3,4, *recon_green.shape)
ROI_bkgd = np.zeros(recon_red.shape, dtype=bool)
ROI_bkgd[460:510,240:290,150:300] = 1
```

2. ROI analysis: The mean intensity and standard deviation of the intensity are calculated for each ROI.

```python
print("RED")
img_ROI_red = recon_red.copy()
img_ROI_red = np.ma.asarray(img_ROI_red)
std_red = np.zeros(ROI_red.shape[:2])
mean_red = np.zeros(ROI_red.shape[:2])
for i,j in np.ndindex(ROI_red.shape[:2]):
    img_ROI_red.mask = ~ROI_red[i,j]
    std_red[i,j] = img_ROI_red.std()
    mean_red[i,j] = img_ROI_red.mean()
    print(i,j,std_red[i,j],mean_red[i,j])
img_ROI_red.mask = ~ROI_bkgd
mean_bkgd_red = recon_red[ROI_bkgd].mean()
std_bkgd_red = recon_red[ROI_bkgd].std()
print("mean_bkgd_red:",mean_bkgd_red)
print("std_bkgd_red:",std_bkgd_red)

print("GREEN")
img_ROI_green = recon_green.copy()
img_ROI_green = np.ma.asarray(img_ROI_green)
std_green = np.zeros(ROI_green.shape[:2])
mean_green = np.zeros(ROI_green.shape[:2])
for i,j in np.ndindex(ROI_green.shape[:2]):
    img_ROI_green.mask = ~ROI_green[i,j]
    std_green[i,j] = img_ROI_green.std()
    mean_green[i,j] = img_ROI_green.mean()
    print(i,j,std_green[i,j],mean_green[i,j])
img_ROI_green.mask = ~ROI_bkgd
mean_bkgd_green= recon_green[ROI_bkgd].mean()
std_bkgd_green = recon_green[ROI_bkgd].std()
print("mean_bkgd_green:",mean_bkgd_green)
print("std_bkgd_green:",std_bkgd_green)
```

3. Calculate the SNR:

```python
SNR_red = 10*np.log10(mean_red/std_red)
SNR_green = 10*np.log10(mean_green/std_green)
```

4. Calculate the CNR: comparing the ROI with the background.

```python
CNR_red = CNR(mean_red,mean_bkgd_red,std_red,std_bkgd_red)
CNR_green = CNR(mean_green,mean_bkgd_green,std_green,std_bkgd_green)
```

## Results

1. mean and sigam

RED
0 0 0.0054555585413877256 0.20241074022715266
0 1 0.0012481424310881106 0.1832290676175383
0 2 0.002377871563370121 0.1740008914421553
0 3 0.0009563313547626128 0.15114830956154252
1 0 0.01476393731054355 0.2954089078182779
1 1 0.005561419931256029 0.2732364797939778
1 2 0.002512980311819522 0.24226234812466985
1 3 0.007569469030688199 0.19095907620179609
2 0 0.01541335930867416 0.30675581088219755
2 1 0.006577881396321911 0.28389758320126784
2 2 0.004137876365125819 0.26017102482831483
2 3 0.0012340643261229305 0.19322809363444268
mean_bkgd_red: 0.13641556
std_bkgd_red: 0.0011293304
GREEN
0 0 0.012607896949533737 0.2868932910723719
0 1 0.003999190256830179 0.251115573824617
0 2 0.002370307657097882 0.2291310915213946
0 3 0.0011198279205868551 0.17590332805071315
1 0 0.0017168981734451546 0.17171574550977284
1 1 0.0008065685267407611 0.16030333795562599
1 2 0.0014177439277306856 0.15251434561542526
1 3 0.0015688490364440789 0.14315114896988906
2 0 0.01334563826828201 0.3029712097200211
2 1 0.005096316661679574 0.27632684561542525
2 2 0.0029484382164437174 0.25049707805071314
2 3 0.001055449256161004 0.1871939381933439
mean_bkgd_green: 0.13430834
std_bkgd_green: 0.0

2. SNR (dB)

RED
[[15.69394333 21.66730224 18.6436308  21.98794899]
 [13.01221395 16.91352993 19.84096836 14.01874889]
 [12.98895496 16.35075657 17.98481417 21.94732471]]
GREEN
[[13.57077742 17.97901582 19.85279305 21.96122765]
 [20.00065581 22.98301294 20.317129   19.60213683]
 [13.56062012 17.34166674 19.29210633 22.48854423]]

3. CNR (dB)

RED
[[10.7356184  14.44229034 11.5466246   9.98066159]
 [10.30909924 13.82192359 15.84543736  8.52897215]
 [10.42257368 13.44344927 14.60186081 15.30996912]]
GREEN
[[10.82869058 14.6549768  16.02107842 15.69889732]
 [13.3821307  15.08248547 11.0861692   7.51009178]
 [11.01680141 14.45088539 15.9557201  16.99900078]]

